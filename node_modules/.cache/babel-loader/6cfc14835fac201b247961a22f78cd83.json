{"ast":null,"code":"'use strict'; // expose to the world\n\nmodule.exports = addressparser;\n/**\n * Parses structured e-mail addresses from an address field\n *\n * Example:\n *\n *    'Name <address@domain>'\n *\n * will be converted to\n *\n *     [{name: 'Name', address: 'address@domain'}]\n *\n * @param {String} str Address field\n * @return {Array} An array of address objects\n */\n\nfunction addressparser(str) {\n  var tokenizer = new Tokenizer(str);\n  var tokens = tokenizer.tokenize();\n  var addresses = [];\n  var address = [];\n  var parsedAddresses = [];\n  tokens.forEach(function (token) {\n    if (token.type === 'operator' && (token.value === ',' || token.value === ';')) {\n      if (address.length) {\n        addresses.push(address);\n      }\n\n      address = [];\n    } else {\n      address.push(token);\n    }\n  });\n\n  if (address.length) {\n    addresses.push(address);\n  }\n\n  addresses.forEach(function (address) {\n    address = _handleAddress(address);\n\n    if (address.length) {\n      parsedAddresses = parsedAddresses.concat(address);\n    }\n  });\n  return parsedAddresses;\n}\n/**\n * Converts tokens for a single address into an address object\n *\n * @param {Array} tokens Tokens object\n * @return {Object} Address object\n */\n\n\nfunction _handleAddress(tokens) {\n  var token;\n  var isGroup = false;\n  var state = 'text';\n  var address;\n  var addresses = [];\n  var data = {\n    address: [],\n    comment: [],\n    group: [],\n    text: []\n  };\n  var i;\n  var len; // Filter out <addresses>, (comments) and regular text\n\n  for (i = 0, len = tokens.length; i < len; i++) {\n    token = tokens[i];\n\n    if (token.type === 'operator') {\n      switch (token.value) {\n        case '<':\n          state = 'address';\n          break;\n\n        case '(':\n          state = 'comment';\n          break;\n\n        case ':':\n          state = 'group';\n          isGroup = true;\n          break;\n\n        default:\n          state = 'text';\n      }\n    } else if (token.value) {\n      if (state === 'address') {\n        // handle use case where unquoted name includes a \"<\"\n        // Apple Mail truncates everything between an unexpected < and an address\n        // and so will we\n        token.value = token.value.replace(/^[^<]*<\\s*/, '');\n      }\n\n      data[state].push(token.value);\n    }\n  } // If there is no text but a comment, replace the two\n\n\n  if (!data.text.length && data.comment.length) {\n    data.text = data.comment;\n    data.comment = [];\n  }\n\n  if (isGroup) {\n    // http://tools.ietf.org/html/rfc2822#appendix-A.1.3\n    data.text = data.text.join(' ');\n    addresses.push({\n      name: data.text || address && address.name,\n      group: data.group.length ? addressparser(data.group.join(',')) : []\n    });\n  } else {\n    // If no address was found, try to detect one from regular text\n    if (!data.address.length && data.text.length) {\n      for (i = data.text.length - 1; i >= 0; i--) {\n        if (data.text[i].match(/^[^@\\s]+@[^@\\s]+$/)) {\n          data.address = data.text.splice(i, 1);\n          break;\n        }\n      }\n\n      var _regexHandler = function (address) {\n        if (!data.address.length) {\n          data.address = [address.trim()];\n          return ' ';\n        } else {\n          return address;\n        }\n      }; // still no address\n\n\n      if (!data.address.length) {\n        for (i = data.text.length - 1; i >= 0; i--) {\n          // fixed the regex to parse email address correctly when email address has more than one @\n          data.text[i] = data.text[i].replace(/\\s*\\b[^@\\s]+@[^\\s]+\\b\\s*/, _regexHandler).trim();\n\n          if (data.address.length) {\n            break;\n          }\n        }\n      }\n    } // If there's still is no text but a comment exixts, replace the two\n\n\n    if (!data.text.length && data.comment.length) {\n      data.text = data.comment;\n      data.comment = [];\n    } // Keep only the first address occurence, push others to regular text\n\n\n    if (data.address.length > 1) {\n      data.text = data.text.concat(data.address.splice(1));\n    } // Join values with spaces\n\n\n    data.text = data.text.join(' ');\n    data.address = data.address.join(' ');\n\n    if (!data.address && isGroup) {\n      return [];\n    } else {\n      address = {\n        address: data.address || data.text || '',\n        name: data.text || data.address || ''\n      };\n\n      if (address.address === address.name) {\n        if ((address.address || '').match(/@/)) {\n          address.name = '';\n        } else {\n          address.address = '';\n        }\n      }\n\n      addresses.push(address);\n    }\n  }\n\n  return addresses;\n}\n/**\n * Creates a Tokenizer object for tokenizing address field strings\n *\n * @constructor\n * @param {String} str Address field string\n */\n\n\nfunction Tokenizer(str) {\n  this.str = (str || '').toString();\n  this.operatorCurrent = '';\n  this.operatorExpecting = '';\n  this.node = null;\n  this.escaped = false;\n  this.list = [];\n}\n/**\n * Operator tokens and which tokens are expected to end the sequence\n */\n\n\nTokenizer.prototype.operators = {\n  '\"': '\"',\n  '(': ')',\n  '<': '>',\n  ',': '',\n  ':': ';',\n  // Semicolons are not a legal delimiter per the RFC2822 grammar other\n  // than for terminating a group, but they are also not valid for any\n  // other use in this context.  Given that some mail clients have\n  // historically allowed the semicolon as a delimiter equivalent to the\n  // comma in their UI, it makes sense to treat them the same as a comma\n  // when used outside of a group.\n  ';': ''\n};\n/**\n * Tokenizes the original input string\n *\n * @return {Array} An array of operator|text tokens\n */\n\nTokenizer.prototype.tokenize = function () {\n  var chr,\n      list = [];\n\n  for (var i = 0, len = this.str.length; i < len; i++) {\n    chr = this.str.charAt(i);\n    this.checkChar(chr);\n  }\n\n  this.list.forEach(function (node) {\n    node.value = (node.value || '').toString().trim();\n\n    if (node.value) {\n      list.push(node);\n    }\n  });\n  return list;\n};\n/**\n * Checks if a character is an operator or text and acts accordingly\n *\n * @param {String} chr Character from the address field\n */\n\n\nTokenizer.prototype.checkChar = function (chr) {\n  if ((chr in this.operators || chr === '\\\\') && this.escaped) {\n    this.escaped = false;\n  } else if (this.operatorExpecting && chr === this.operatorExpecting) {\n    this.node = {\n      type: 'operator',\n      value: chr\n    };\n    this.list.push(this.node);\n    this.node = null;\n    this.operatorExpecting = '';\n    this.escaped = false;\n    return;\n  } else if (!this.operatorExpecting && chr in this.operators) {\n    this.node = {\n      type: 'operator',\n      value: chr\n    };\n    this.list.push(this.node);\n    this.node = null;\n    this.operatorExpecting = this.operators[chr];\n    this.escaped = false;\n    return;\n  }\n\n  if (!this.escaped && chr === '\\\\') {\n    this.escaped = true;\n    return;\n  }\n\n  if (!this.node) {\n    this.node = {\n      type: 'text',\n      value: ''\n    };\n    this.list.push(this.node);\n  }\n\n  if (this.escaped && chr !== '\\\\') {\n    this.node.value += '\\\\';\n  }\n\n  this.node.value += chr;\n  this.escaped = false;\n};","map":{"version":3,"sources":["C:/projects/landing/node_modules/addressparser/lib/addressparser.js"],"names":["module","exports","addressparser","str","tokenizer","Tokenizer","tokens","tokenize","addresses","address","parsedAddresses","forEach","token","type","value","length","push","_handleAddress","concat","isGroup","state","data","comment","group","text","i","len","replace","join","name","match","splice","_regexHandler","trim","toString","operatorCurrent","operatorExpecting","node","escaped","list","prototype","operators","chr","charAt","checkChar"],"mappings":"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","sourcesContent":["'use strict';\n\n// expose to the world\nmodule.exports = addressparser;\n\n/**\n * Parses structured e-mail addresses from an address field\n *\n * Example:\n *\n *    'Name <address@domain>'\n *\n * will be converted to\n *\n *     [{name: 'Name', address: 'address@domain'}]\n *\n * @param {String} str Address field\n * @return {Array} An array of address objects\n */\nfunction addressparser(str) {\n    var tokenizer = new Tokenizer(str);\n    var tokens = tokenizer.tokenize();\n\n    var addresses = [];\n    var address = [];\n    var parsedAddresses = [];\n\n    tokens.forEach(function (token) {\n        if (token.type === 'operator' && (token.value === ',' || token.value === ';')) {\n            if (address.length) {\n                addresses.push(address);\n            }\n            address = [];\n        } else {\n            address.push(token);\n        }\n    });\n\n    if (address.length) {\n        addresses.push(address);\n    }\n\n    addresses.forEach(function (address) {\n        address = _handleAddress(address);\n        if (address.length) {\n            parsedAddresses = parsedAddresses.concat(address);\n        }\n    });\n\n    return parsedAddresses;\n}\n\n/**\n * Converts tokens for a single address into an address object\n *\n * @param {Array} tokens Tokens object\n * @return {Object} Address object\n */\nfunction _handleAddress(tokens) {\n    var token;\n    var isGroup = false;\n    var state = 'text';\n    var address;\n    var addresses = [];\n    var data = {\n        address: [],\n        comment: [],\n        group: [],\n        text: []\n    };\n    var i;\n    var len;\n\n    // Filter out <addresses>, (comments) and regular text\n    for (i = 0, len = tokens.length; i < len; i++) {\n        token = tokens[i];\n        if (token.type === 'operator') {\n            switch (token.value) {\n                case '<':\n                    state = 'address';\n                    break;\n                case '(':\n                    state = 'comment';\n                    break;\n                case ':':\n                    state = 'group';\n                    isGroup = true;\n                    break;\n                default:\n                    state = 'text';\n            }\n        } else if (token.value) {\n            if (state === 'address') {\n                // handle use case where unquoted name includes a \"<\"\n                // Apple Mail truncates everything between an unexpected < and an address\n                // and so will we\n                token.value = token.value.replace(/^[^<]*<\\s*/, '');\n            }\n            data[state].push(token.value);\n        }\n    }\n\n    // If there is no text but a comment, replace the two\n    if (!data.text.length && data.comment.length) {\n        data.text = data.comment;\n        data.comment = [];\n    }\n\n    if (isGroup) {\n        // http://tools.ietf.org/html/rfc2822#appendix-A.1.3\n        data.text = data.text.join(' ');\n        addresses.push({\n            name: data.text || (address && address.name),\n            group: data.group.length ? addressparser(data.group.join(',')) : []\n        });\n    } else {\n        // If no address was found, try to detect one from regular text\n        if (!data.address.length && data.text.length) {\n            for (i = data.text.length - 1; i >= 0; i--) {\n                if (data.text[i].match(/^[^@\\s]+@[^@\\s]+$/)) {\n                    data.address = data.text.splice(i, 1);\n                    break;\n                }\n            }\n\n            var _regexHandler = function (address) {\n                if (!data.address.length) {\n                    data.address = [address.trim()];\n                    return ' ';\n                } else {\n                    return address;\n                }\n            };\n\n            // still no address\n            if (!data.address.length) {\n                for (i = data.text.length - 1; i >= 0; i--) {\n                    // fixed the regex to parse email address correctly when email address has more than one @\n                    data.text[i] = data.text[i].replace(/\\s*\\b[^@\\s]+@[^\\s]+\\b\\s*/, _regexHandler).trim();\n                    if (data.address.length) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        // If there's still is no text but a comment exixts, replace the two\n        if (!data.text.length && data.comment.length) {\n            data.text = data.comment;\n            data.comment = [];\n        }\n\n        // Keep only the first address occurence, push others to regular text\n        if (data.address.length > 1) {\n            data.text = data.text.concat(data.address.splice(1));\n        }\n\n        // Join values with spaces\n        data.text = data.text.join(' ');\n        data.address = data.address.join(' ');\n\n        if (!data.address && isGroup) {\n            return [];\n        } else {\n            address = {\n                address: data.address || data.text || '',\n                name: data.text || data.address || ''\n            };\n\n            if (address.address === address.name) {\n                if ((address.address || '').match(/@/)) {\n                    address.name = '';\n                } else {\n                    address.address = '';\n                }\n\n            }\n\n            addresses.push(address);\n        }\n    }\n\n    return addresses;\n}\n\n/**\n * Creates a Tokenizer object for tokenizing address field strings\n *\n * @constructor\n * @param {String} str Address field string\n */\nfunction Tokenizer(str) {\n    this.str = (str || '').toString();\n    this.operatorCurrent = '';\n    this.operatorExpecting = '';\n    this.node = null;\n    this.escaped = false;\n\n    this.list = [];\n}\n\n/**\n * Operator tokens and which tokens are expected to end the sequence\n */\nTokenizer.prototype.operators = {\n    '\"': '\"',\n    '(': ')',\n    '<': '>',\n    ',': '',\n    ':': ';',\n    // Semicolons are not a legal delimiter per the RFC2822 grammar other\n    // than for terminating a group, but they are also not valid for any\n    // other use in this context.  Given that some mail clients have\n    // historically allowed the semicolon as a delimiter equivalent to the\n    // comma in their UI, it makes sense to treat them the same as a comma\n    // when used outside of a group.\n    ';': ''\n};\n\n/**\n * Tokenizes the original input string\n *\n * @return {Array} An array of operator|text tokens\n */\nTokenizer.prototype.tokenize = function () {\n    var chr, list = [];\n    for (var i = 0, len = this.str.length; i < len; i++) {\n        chr = this.str.charAt(i);\n        this.checkChar(chr);\n    }\n\n    this.list.forEach(function (node) {\n        node.value = (node.value || '').toString().trim();\n        if (node.value) {\n            list.push(node);\n        }\n    });\n\n    return list;\n};\n\n/**\n * Checks if a character is an operator or text and acts accordingly\n *\n * @param {String} chr Character from the address field\n */\nTokenizer.prototype.checkChar = function (chr) {\n    if ((chr in this.operators || chr === '\\\\') && this.escaped) {\n        this.escaped = false;\n    } else if (this.operatorExpecting && chr === this.operatorExpecting) {\n        this.node = {\n            type: 'operator',\n            value: chr\n        };\n        this.list.push(this.node);\n        this.node = null;\n        this.operatorExpecting = '';\n        this.escaped = false;\n        return;\n    } else if (!this.operatorExpecting && chr in this.operators) {\n        this.node = {\n            type: 'operator',\n            value: chr\n        };\n        this.list.push(this.node);\n        this.node = null;\n        this.operatorExpecting = this.operators[chr];\n        this.escaped = false;\n        return;\n    }\n\n    if (!this.escaped && chr === '\\\\') {\n        this.escaped = true;\n        return;\n    }\n\n    if (!this.node) {\n        this.node = {\n            type: 'text',\n            value: ''\n        };\n        this.list.push(this.node);\n    }\n\n    if (this.escaped && chr !== '\\\\') {\n        this.node.value += '\\\\';\n    }\n\n    this.node.value += chr;\n    this.escaped = false;\n};\n"]},"metadata":{},"sourceType":"script"}